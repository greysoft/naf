/*
 * Copyright 2011-2024 Yusef Badri - All rights reserved.
 * NAF is distributed under the terms of the GNU Affero General Public License, Version 3 (AGPLv3).
 */
package com.grey.naf.reactor;

import java.util.List;

import com.grey.base.collections.Circulist;
import com.grey.base.utils.ByteArrayRef;
import com.grey.base.utils.NIOBuffers;
import com.grey.naf.BufferGenerator;
import com.grey.logging.Logger.LEVEL;

/*
 * This class allows a Dispatcher to act as a consumer of events generated by an external Producer
 * which may well be running in a different thread (hence the Dispatcher thread is also known as the
 * Consumer thread).
 * Although this class is called Producer and is owned by the Dispatcher, the actual producer is the
 * external entity who calls its produce() methods, and this class is their proxy.
 */
public class Producer<T> implements DispatcherRunnable
{
	public interface Consumer<T> {
		void producerIndication(Producer<T> p) throws java.io.IOException;
	}

	private final String name;
	private final Consumer<T> consumer;
	private final Circulist<T> exchgq;  //MT queue, on which Dispatcher receives items from producer
	private final Circulist<T> availq;  //non-MT staging queue, only accessed by the Dispatcher
	private final AlertsPipe<T> alertspipe;
	private final com.grey.logging.Logger logger;
	private boolean in_shutdown;

	@Override
	public String getName() {return name;}
	@Override
	public Dispatcher getDispatcher() {return alertspipe.getDispatcher();}
	@Override
	public boolean stopDispatcherRunnable() {shutdown(false); return true;}

	public Producer(String producerName, Dispatcher dsptch, Consumer<T> itemConsumer) throws java.io.IOException {
		name = producerName;
		consumer = itemConsumer;
		exchgq = new Circulist<>();
		availq = new Circulist<>();
		alertspipe = new AlertsPipe<>(dsptch, this);
		logger = dsptch.getLogger();
	}

	@Override
	public void startDispatcherRunnable() throws java.io.IOException {
		logger.info("Dispatcher="+getDispatcher().getName()+" starting Producer="+this);
		alertspipe.start();
	}

	// If some items are already on the available queue, then we don't attempt to consume them even if
	// the 'consume' arg is true, as this shutdown could be occurring during a notifyConsumer() callout,
	// in which case the caller has already decided to abort.
	public void shutdown(boolean consume_pending) {
		if (in_shutdown) return;
		try {
			alertspipe.shutdown();
		} catch (Throwable ex) {
			logger.log(LEVEL.INFO, ex, true, "Error on Producer shutdown - "+this);
		}
		int ready = availq.size();
		takePendingItems();
		int pending = availq.size() - ready;

		logger.info("Shutdown Producer with pending="+ready+"+"+pending+"/drain="+consume_pending+" - "+this);
		if (consume_pending && ready == 0 && pending != 0) {
			notifyConsumer();
			logger.info("Shutdown Producer="+this+": Drainage completed - pending="+availq.size());
		}
		in_shutdown = true; // don't set this till after we've drained any pending events
	}

	public T consume() {
		if (availq.size() == 0) return null;
		return availq.remove();
	}

	public void produce(T item) throws java.io.IOException {
		int cnt;
		synchronized (exchgq) {
			cnt = exchgq.size();
			exchgq.append(item);
		}
		produce(cnt);
	}

	public void produce(List<T> items) throws java.io.IOException {
		int cnt;
		synchronized (exchgq) {
			cnt = exchgq.size();
			for (int idx = 0; idx != items.size(); idx++) {
				exchgq.append(items.get(idx));
			}
		}
		produce(cnt);
	}

	public void produce(T[] items, int off, int len) throws java.io.IOException {
		int lmt = off + len;
		int cnt;
		synchronized (exchgq) {
			cnt = exchgq.size();
			for (int idx = off; idx != lmt; idx++) {
				exchgq.append(items[idx]);
			}
		}
		produce(cnt);
	}

	public void produce(T[] items) throws java.io.IOException {
		produce(items, 0, items.length);
	}

	// This is the final act of the public produce() methods, which are called by the external producer and
	// are the only methods in this class that might be called by a different thread (ie. not the Dispatcher
	// thread).
	// This method is called internally after exchgq has been populated with the new items, and the Dispatcher arg
	// represents the Dispatcher in the context of which this call is being made. If it's the same as the Dispatcher
	// which owns this Producer object, then it is a synchronous call by an in-thread producer, else we have to use
	// the AlertsPipe to signal the owner Dispatcher.
	// If exchgq already had unconsumed items on it, then we assume the owner Dispatcher has already been signalled,
	// so we can skip the I/O cost of sending it a redundant signal.
	private void produce(int exchq_prevsize) throws java.io.IOException {
		if (getDispatcher().isDispatcherThread()) {
			producerEvent(); //we can synchronously call the Consumer
		} else {
			if (exchq_prevsize == 0) alertspipe.signalConsumer();  //one signal is enough
		}
	}

	private void notifyConsumer() {
		int ready = availq.size();
		if (in_shutdown || ready == 0) return;
		try {
			consumer.producerIndication(this);
		} catch (Throwable ex) {
			logger.log(LEVEL.INFO, ex, true, "Consumer failed to handle Producer-indication - left="+availq.size()+"/"+ready+" - "+this);
		}
	}

	private void takePendingItems() {
		synchronized (exchgq) {
			while (exchgq.size() != 0) {
				availq.append(exchgq.remove());
			}
		}
	}

	private void producerEvent() {
		takePendingItems();
		notifyConsumer();
	}

	@Override
	public String toString() {
		return super.toString()+" Name="+getName()+" with consumer="+consumer.getClass().getName()+"/"+consumer
				+" - Dispatcher="+alertspipe.getDispatcher().getName()+", alertspipe="+alertspipe.getCMID();
	}


	/*
	 * Encapsulate the ChannelMonitor functionality within a nested class, rather than making it a base class for Producer.
	 * We prefer composition to inheritance, not least because if Producer inherited from ChannelMonitor, it would expose all its methods.
	 * This ChannelMonitor receives I/O indications from the Producer thread(s).
	 * This class is non-private only because Dispatcher.dumpState() needs to be able to see it.
	 */
	static final class AlertsPipe<T> extends CM_Stream {
		private final Producer<T> producer;
		private final java.nio.channels.Pipe.SinkChannel wep;   //Write end-point of pipe
		private final java.nio.channels.Pipe.SourceChannel rep; //Read end-point of pipe
		private final java.nio.ByteBuffer rcvbuf;

		public Producer<T> getProducer() {return producer;}

		// Note that 'rep' and 'CM_Stream.iochan' are one and the same, but recording it as rep allows us to avoid casting iochan.
		private AlertsPipe(Dispatcher d, Producer<T> p) throws java.io.IOException {
			super(d, new BufferGenerator(0, 0), null); //we will do our own reads
			producer = p;

			java.nio.channels.Pipe pipe = java.nio.channels.Pipe.open();
			rep = pipe.source(); //Read end-point
			wep = pipe.sink();
			wep.configureBlocking(false); //guaranteed not to block in practice
			rcvbuf = NIOBuffers.create(16, true);
		}

		// enable event notifications on the read (consumer) endpoint of our pipe		
		private void start() throws java.io.IOException {
			registerConnectedChannel(rep, true);
			getReader().receive(0);
		}

		private void shutdown() throws java.io.IOException {
			wep.close();
			disconnect();
		}

		// This is called by Producers outside the Dispatcher thread.
		// We don't care if the write() returns zero because it's blocked. We are not sending data which the
		// consumer has to read, but merely kicking it into action, and if the pipe is full, then the
		// consumer will surely be signalled that I/O is pending.
		private synchronized void signalConsumer() throws java.io.IOException {
			java.nio.ByteBuffer buf = NIOBuffers.create(1, false);
			wep.write(buf);
		}

		// This happens within the Dispatcher (consumer) thread.
		// We don't care what's in rcvbuf, we just read it off to clear the I/O notification.
		@Override
		public void ioReceived(ByteArrayRef data) throws java.io.IOException {
			rcvbuf.clear();
			rep.read(rcvbuf);
			producer.producerEvent();
		}
	}
}
